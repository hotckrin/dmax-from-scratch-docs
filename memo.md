| 装備名                  | 装備個数 |
|-------------------------|----------|
| レダゼルトヘルムγ       | 1        |
| レダゼルトメイルγ       | 1        |
| レダゼルトアームγ       | 1        |
| レダゼルトコイルγ       | 1        |
| レダゼルトグリーヴγ     | 1        |
| ラギアヘルムα           | 0        |
| ラギアメイルα           | 0        |
| ラギアアームα           | 0        |
| ラギアコイルα           | 0        |
| ラギアグリーヴα         | 0        |
| 挑戦の護石Ⅱ            | 1        |
| 反攻の護石Ⅲ            | 0        |
| 反攻珠【３】            | 3        |
| 痛撃珠【３】            | 1        |

制約条件(1): 各部位で装備できる個数は1以下 (部位は次の7つ 頭・胴・腕・腰・脚・護石・武器)
制約条件(2): ユーザが指定したスキルレベルの条件を満たす
制約条件(3): 装飾品はスロットレベル以上の大きさのスロットにしか装着できない
制約条件(4): ダメージ計算式において有効な同名スキルのスキルレベルは1つのみ
制約条件(5): ダメージ計算式において有効なスキルは装備中のスキルのみ
制約条件(6): 会心率の上限は100%


check list
- [x] dmax-mini-1.py の解説 制約(1)
- [x] dmax-mini-2.py の解説 制約(2)
- [x] dmax-mini-3.py の解説 制約(3)
- [x] dmax-mini-4.py の解説 制約(4), (5), (6) + ダメージ計算式
- [x] dmax.py の準備
- [ ] mini 別の実行方法の修正
- [ ] dmax-practice を mini 側に追加、 __main__ 削除対応
- [ ] dmax.py の解説 ちょっとだけ書く
- [ ] 書き直し「どうやって式に落とし込めばよいか？」
- [x] コードのアップロード
- [ ] github へのリンク
- [ ] すぐ試したい人向けの解説
  - [ ] web版 dmax mhwilds の動作イメージ図
  - [ ] コード動かし方
- [x] 環境構築 記事とアップロードされたコードをベースに実行できることまで確認する
- [ ] 参考文献などをまとめる
- [ ] ユーザ提供するためのハードル
  - web サービス化, wasm 化の話
  - 泥臭い部分
    - ダメージ計算式を割り出す
    - データを整形して入力する
    - 便利なUIを実装する
    - ソルバをどこで動かすか？


画像準備
- [ ] ダメージ計算式の概念図
- [x] 最適化処理は丸投げ、のかわりに定式化をがんばる、次回作にも流用できるのイメージ図
- [x] 流れのイメージ図: pyomo → 問題ファイル → scip ソルバー
- [x] テーブルとコードの変数を対応させる
- [x] 装飾品スロット数の議論のイメージ図

妥協したTODO

```
TODO: テーブルから列を抽出して和積を計算している図を書く

以下の部分では、まずユーザが指定した必須スキルレベルのデータ `required_skills` をパラメータ `mdl.r` としてモデルに追加しています。
`mdl.r` の定義においてもインデックスとして `required_skills.keys()` を指定することで一括でパラメータを追加しています。
さらに関数 `const_skill_point()` の部分では以下のような形で制約条件(2)に相当する式を定義しています。
```




## 移植メモ
テーブル形式で必要な準備、変数、制約条件、目的関数をまとめて、実装するたびにチェックしていく

- Param 準備
- 変数準備
- 制約条件1
- 制約条件2
- ...
- 目的関数
- 武器情報の入力
- required skill 制約条件
- deco 制約条件


ステップ
1. 防具 + 護石
2. 防具 + 護石 + 装飾品
3. 防具 + 護石 + 装飾品 + スキル下限レベル


ワイルズの最適化シミュレータを作成するうえでの課題は以下です。


- 装備の制約条件
  - 各装備は1個以下しか装備できない (装備するか、装備しないかの2択)
  - 各部位ごとに装備できる防具は1個以下
  - 配列の考え方
- グループスキルの考え方
- 装飾品の制約条件
  - 装飾品は装飾品スロットLv以下のものしか着けられない
- スキルの制約条件
  - 同じスキルのうち、1つのレベルだけが有効になる
- ダメージ計算式
  - スキルが発動したときにダメージ計算式に影響を及ぼすことを式で表現する
  - 加算スキルの表現方法
  - 乗算スキルの表現方法
- 会心率の制約条件
  - 会心率は 100% を超えることはできない
- ユーザが指定したスキルレベルの制約条件
  - ユーザが指定したスキルレベルの下限以上になる装備構成を出力したい
- 定数の管理


ここから必要なデータを整理する
- 武器装飾品
- 防具装飾品
- 攻撃系スキル
- 会心系スキル
- 属性系スキル


装飾品の考え方
簡単のために Lv1装飾品は Lv2 に装着できないとする

armor_a := Lv1スロットが1つ, Lv2スロットが2つ
armor_b := Lv1スロットが2つ, Lv2スロットが1つ

deco_j := Lv1装飾品
deco_k := Lv1装飾品

deco_l := Lv2装飾品
deco_m := Lv2装飾品

1 * use_armor_a  + 2 * use_armor_b >= num_deco_j + num_deco_k
2 * use_armor_a  + 1 * use_armor_b >= num_deco_l + num_deco_m

Lv1装飾品は Lv2 にも装着できる

3 * use_armor_a  + 3 * use_armor_b >= num_deco_j + num_deco_k                                # <- 1スロ装飾品は Lv2スロットにも装着できる
2 * use_armor_a  + 1 * use_armor_b >= (num_deco_l + num_deco_m) + (num_deco_j + num_deco_k)  # <- 1スロ装飾品が Lv2スロットを使ったら、その分Lv2スロットの枠を消費すべき

3 * use_armor_a  + 3 * use_armor_b >= (num_deco_j + num_deco_k) + (num_deco_l + num_deco_m)
2 * use_armor_a  + 1 * use_armor_b >= (num_deco_l + num_deco_m)


1スロはlv2にもはまるので上の式に足しておく

困った点
・lv2がレベルにハマるよにみえる→でも下の式で抑えられているからok

・実際はlv2スロは1と2で取り合うべきなので上の式か下の式のどちらかに1と2の両方を追加して取り合うようにすべき
上下のどちらの式を修正しても問題ないように見える
ほげ — 昨日 20:10
アプローチ
lv2スロには1も2もはいる
←上か下の式を修正
ただこれだと1と2によるスロットの取り合いが発生しない
←増やした差分ポイント分は2も消費するので上の式に2をいれる
or
←増やした差分を1が消費するのはいいが、lv2は1と2で取り合うべきなので下の式に1を追加する
ほげ — 10:04
↑これ不等号逆でも成り立つは嘘だった

下のlv2スロの制約式にスロ1装飾品をいれることで、スロ2とスロ1の枠の取り合いを起こそうとすると、実際にはlv1スロがまだ余っているのに、lv2スロ側の制約をうけて スロ1が装着できなくなってしまう



use_armor_a * 2  + use_armor_b * 2 * b_s1 >= num_deco_j + num_deco_k


---- 8/4: 装飾品の説明を考え直す ----

まず、簡単のために装飾品は全く同じLvにしか装着できないとすると

(装備のLv1スロット数) >= (Lv1装飾品の数)
(装備のLv2スロット数) >= (Lv2装飾品の数)

より正確に表現すると

(使用する全ての装備のLv1スロット数) >= (使用する全ての装備のLv1装飾品の数)
(使用する全ての装備のLv2スロット数) >= (使用する全ての装備のLv2装飾品の数)


実際は装備のLv2スロットにはLv1装飾品を装着できるので、 (装備のLv2スロット数) の式の右辺には Lv1装飾品も入れて良い
これにより、Lv2スロットは Lv2装飾品とLv1装飾品が、ダメージを最大化するために取り合うようになる

(装備のLv1スロット数) >= (Lv1装飾品の数)
(装備のLv2スロット数) >= (Lv2装飾品の数) + (Lv1装飾品の数)

↑これはダメだった。
なぜなら 下の式で Lv2装飾品が全ての Lv2スロット数を埋めきった場合 (10 >= (10) + 0)、まだ Lv1スロが残っているにもかかわらず、Lv1装飾品が装着できなくなってしまう
↓以下間違い

同様に考えて

(装備のLv1スロット数) >= (Lv1装飾品の数)
(装備のLv2スロット数) >= (Lv1装飾品の数) + (Lv2装飾品の数)
(装備のLv3スロット数) >= (Lv1装飾品の数) + (Lv2装飾品の数) + (Lv3装飾品の数)

つまり
(装備のLv1スロット数) >= (Lv1以下の装飾品の数)
(装備のLv2スロット数) >= (Lv2以下の装飾品の数)
(装備のLv3スロット数) >= (Lv3以下の装飾品の数)

移項すると

(装備のLv1スロット数) - (Lv1装飾品の数)                                     >= 0
(装備のLv2スロット数) - (Lv1装飾品の数) - (Lv2装飾品の数)                   >= 0
(装備のLv3スロット数) - (Lv1装飾品の数) - (Lv2装飾品の数) + (Lv3装飾品の数) >= 0

スロットLv3の余り数属性 RemainSlotLv3 を考えると

Lv3スロットが n 個ある装備の属性 RemainSlotLv3 = +n
Lv3装飾品は RemainSlotLv3 を消費するので RemainSlotLv3 = -1
Lv1装飾品は RemainSlotLv3 を消費するので RemainSlotLv3 = -1
Lv1装飾品は RemainSlotLv2 を消費するので RemainSlotLv2 = -1
Lv1装飾品は RemainSlotLv1 を消費するので RemainSlotLv1 = -1


考かんがえてはダメか？ → ダメという話 (の予定だったが、うえは間違いで、こっちのほうが最終的には正しかった)

Lv1装飾品はLv2スロットにも装着できるので、1番目の式の左辺に (装備のLv2スロット数) を加える
(装備のLv2スロット数) + (装備のLv1スロット数) >= (Lv1装飾品の数)
(装備のLv2スロット数)                         >= (Lv2装飾品の数)

このままでは Lv2スロットが2倍存在しているだけになる
実際には Lv2スロットは Lv1装飾品と Lv2装飾品で取り合うべき
なので (装備のLv2スロット数) の右辺に (Lv1装飾品の数) を加えることで Lv2スロットの取り合いを発生させる


(装備のLv2スロット数) + (装備のLv1スロット数) >= (Lv1装飾品の数)
(装備のLv2スロット数)                         >= (Lv2装飾品の数) + (Lv1装飾品の数)   # → Lv2枠を Lv1装飾品と Lv2装飾品で取り合っているので良さそう...?

これそれぞれの式を個別に見ると理屈はもっともらし気がしませんか？
私は最初こう考えて、これのどこか間違っているか説明できませんでした。

実際には 下側の式で Lv2装飾品が全て Lv2スロットを埋めきったときに、上の式ではまだ Lv1スロットが余っているにもかかわらず、Lv1装飾品を使用できなくなってしまう
(この記述おかしい→) では、下の式にさらに拡張して 左辺に (装備のLv1スロットの枠を用意してやるとどうなるかというと)

これは行けそうな気がする...？

(装備のLv2スロット数) + (装備のLv1スロット数) >= (Lv2装飾品の数) + (Lv1装飾品の数)   # →Lv2装飾品で Lv1枠とLv2枠を全部埋めようとしても下の式で Lv2装飾品数は制限されるので良さそう...?
(装備のLv2スロット数)                         >= (Lv2装飾品の数)

上記の2式の懸念点は、上の式でLv1スロにもLv2装飾品が占有してしまうことです。本来ハマるはずのないLv1スロにLv2装飾品がハマってしまう懸念があります。
しかし、下の式によってLv2スロは装備のLv2スロ数に収まるように制限されているので、結局は装備のLv2スロット数分しか消費せず、上の式において、Lv1スロを食いつぶしてしまうことはありません。
逆にLv1スロはLv2スロを埋めた際にはLv2スロ枠は上の式で消費され、Lv2装飾品のハマる枠が減ることがわかります。

(装備のLv3スロット数) + (装備のLv2スロット数) + (装備のLv1スロット数) >= (Lv3装飾品の数) + (Lv2装飾品の数) + (Lv1装飾品の数)
(装備のLv3スロット数) + (装備のLv2スロット数)                         >= (Lv3装飾品の数) + (Lv2装飾品の数)
(装備のLv3スロット数)                                                 >= (Lv3装飾品の数)

つまりは
(装備のLv1以上のスロット数) >= (Lv1以上の装飾品の数)
(装備のLv2以上のスロット数) >= (Lv2以上の装飾品の数)
(装備のLv3以上のスロット数) >= (Lv3以上の装飾品の数)


↑これは 480さんの結果とも一致した (https://github.com/13-480/lp-doc/blob/main/lpsim-v4.pdf)


## 変数同士の掛け算は解くのが遅くなる

## 書きたいこと

- 立式のルールを短く解説する
  - 一番困るのはここのはず
  - 解はなにか、パラメータはなにか、補助変数の導入

- 最初に実行から入ったほうが興味をもたれやすいかも
  - web版 dmax があるからいいかな...?

- 結論だけみたい人、最終成果物だけみたい人にはそれを誘導したい

- サンプルコードの github を公開してリンクを張りたい

- 文章だけでは読むのが大変なので、認識をすり合わせるための模式図を追加したい

- 装備データを表す2次元配列は展開した形式も書くべき

- とりあえず動くものを小さく作って動かす (最小構成で動かす)

- level に0を含めているので level の合計値 == 1 とシンプルに書ける
- level7 もないスキルに level7 まで一式で用意することで、シンプルに書けている
- 変数が増えているので負荷は上る可能性があるが、そのような小手先の最適化をしても最適化ソルバーの高度なアルゴリズムのまえでは誤差に等しい... かもしれないという読みです

- ダメージ最大化問題における最適解とはなにか？
  - 装備を何個使うかを表したベクトル です
  - 全探索すればいい → 無理 → 最適化ソルバーへ

- もっと概要が一目瞭然にわかるように書きたい
  - 基本方針は「最適化ソルバーにおまかせ！」
  - 線形でなくても解けるよ！
  - 式に落とし込むことがすべて
  - ダメージ計算式を推測する、キャッチアップするのが困難


- どういう制約式なら解けるのか？
  - 変数と定数で表現する
  - 閉じていないといけない
  - 線形なら軽い
  - 非線形でも解けるが重くなっていく
  - 重すぎると有限時間内に解けなくなる
    - 重さ対決! サンブレイク vs ワイルズ

- 条件を数式に落とし込む
  - 装備は 0, 1 変数で表現 (-1 とか 2とかない)
  - もう少し別の例
    - スキルの on/off や必須スキル
  - 装飾品の考え方
  - 必須スキル指定


- 環境構築が最大の難関
  - 環境の概要図を書く (問題ファイル作成は python + pyomo 作成した問題を解くのが scip)
- dmax-practice
  - pyomo -> 問題ファイル -> scip ソルバ -> 出力
- 実データ簡易版
  - データ準備、入力準備
  - dmax コード書いて動作まで確認
  - dmax コードの解説
    - 数式？ 行列はなくても 説明できるかも？

- 泥臭い部分
  - ダメージ計算式を割り出す
  - データを整形して入力する
  - 便利なUIを実装する
  - ソルバをどこで動かすか？

- グラフ化したこと と 線形性、非線形の説明があまりつながっていない

- web サービス化編
- web サービス化 wasm 編
